# Building Distributed Application in Gin

Distributed Applications are the new style of development of software these days.
My goals to read this book are to know how:

- How to build a RESTful application using GIN and how to structure it.
- Learning the MongoDB drive in Go;
- How to scale a Web Application using Docker;
- How to deploy a Web Application to the cloud; and
- How to set up a CI/CD for a Web Application.

## Section 1 - Inside the Gin Framework

Gin is a WEB framework with a focus on creating a fast Restful Go application. It offers a set of tools and features that enables developers to build a high-performance web application like Routing, Middlewares, Error Handling, and JSON serialization.

### Chapter 1 - Getting Started with Gin

Gin is one of the fastest web frameworks in the Go language. To create and listen for HTTP requests, just use the `gin.Default()` method that returns an `*Engine` pointer to use as HTTP routing and middleware.

### References

[Gin Framework](https://github.com/gin-gonic/gin)
[What is HTTP Middleware?](https://www.moesif.com/blog/engineering/middleware/What-Is-HTTP-Middleware/)
[Routing in Go](https://benhoyt.com/writings/go-routing/)

## Section 2 - Distributed Microservices

Distributed microservices is an architectural style for building applications that consists of multiple smaller services, each running independently and communicating with each other over a network. Each microservice typically has its API and Database; and communicates with other microservices using protocols such as REST or messaging systems like RabbitMQ.

In this section, we gonna build our Gin microservices with their API using Rest and Database with MongoDB. And we'll integrate them using RabbitMQ as the message system.

### Chapter 2 - Setting Up API Endpoints

We set up our API interface using REST style with Gin because REST protocol is a good fit for **_north-south_** traffic communication. This traffic is when a _consumer_ of the API is out of API's boundary, that is, is out-of-process.

The steps to create a RESTful service are the following:

1. Define the structure of the Model

```go
type Recipe struct {
	ID           primitive.ObjectID `json:"id"`
	Name         string             `json:"name"`
	Tags         []string           `json:"tags"`
	Ingredients  []string           `json:"ingredients"`
	Instructions []string           `json:"instructions"`
	PublishedAt  time.Time          `json:"publishedAt"`
}
```

2. Define the route path name based on the model name. This is the famous _CRUD_ operation and the _resource_ is the name of the model structure.

| HTTP Method | Resource      | Description                       |
| ----------- | ------------- | --------------------------------- |
| GET         | /recipes      | Returns a list of recipes         |
| GET         | /recipes/{id} | Returns a single recipe by its id |
| POST        | /recipes      | Creates a new recipe              |
| PUT         | /recipes{id}  | Updates an existing recipe        |
| DELETE      | /recipes{id}  | Deletes an existing recipe        |

3. Implements the API using Gin framework routing.
   A _routing_ library is just a simple _map table_ where each key is a resource path and the value is an **_HTTP Handler_**.
   ```go
   router.POST("/recipes", recipientHandlers.NewRecipeHandler)
   router.GET("/recipes", recipientHandlers.ListRecipesHandler)
   router.PUT("/recipes/:id", recipientHandlers.UpdateRecipeHandler)
   router.DELETE("/recipes/:id", recipientHandlers.DeleteRecipeHandler)
   router.GET("/recipes/:id", recipientHandlers.GetOneRecipeHandler)
   ```
4. Documents the Rest API using the OpenAPI specification.
   The OpenAPI is a set of patterns that facilitates the documentation of API and allows consumers to understand the interface of the API. We can use the [gin-swagger](https://github.com/swaggo/gin-swagger) tool to generate the OpenAPI specs based on the code implementation.

### Chapter 3 - Managing Data Persistent with MongoDB

#### MongoDB

With the API interface and documentation, the user can now interact with the API to integrate with her application. However, all data generated by the interaction of the user will be lost when the server goes off because all data is saved in memory. For that reason, we need a persistent service to persist the data even if the server is not operating. We gonna use MongoDB for that purpose.

MongoDB is a _NoSQL_ database that uses the _document_ paradigm to structure and organize the data. The MongoDB Driver saves a document in _BSON_ format which is a binary representation of a MongoDB document. To use the driver methods (Insert, Update, Find), we must unmarshal Go struct types into BSON and marshall it to Go struct

```go
// To create a new client instance.
client, err := mongo.Connect(context.Background(), options.CLient().ApplyURI(URI))

// Verify if the server is online.
if err = client.Ping(context.TODO(), readpref.Primary()); err != nil {
	log.Fatal(err)
}

// Connect with a collection.
collection := client.Database(DATABASE).Collection("recipes")
```

#### Redis

Redis is also another _NoSQL_ but it uses the _key/value_ type. This type is like a hash table where the key is the identifier of the value. As the hash table has the _O(1)_ complexity, it is very fast in querying the data. For that reason, Redis is a good choice to use as the Cache system.

```go
// Creates a new Redis Client instance.
redisClient = redis.NewClient(&redis.Options{
	Addr:     ADDR,
	Password: PASSWORD,
	DB:       0,
})

// Verify the status of client instance.
fmt.Println(redisClient.Ping())
```

### References

[Microservices and Distributed Systems](https://cleancommit.io/blog/are-microservices-distributed-systems/)
[REST Paper](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
[OpenAPI Specification](https://swagger.io/specification/)
[NoSQL Databases](https://www.ibm.com/topics/nosql-databases)
[MongoDB BSON](https://www.mongodb.com/docs/drivers/go/current/fundamentals/bson/)
[Redis Caching](https://redis.io/docs/manual/client-side-caching/)
